<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>extern &quot;Rust&quot; — Rust ♡ C++</title>


        <!-- Custom HTML head -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-DG41MK6DDN"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-DG41MK6DDN', {anonymize_ip: true, cookie_domain: 'cxx.rs', cookie_flags: 'samesite=strict;secure'});
        </script>

        <meta name="description" content="CXX — safe interop between Rust and C++ by David Tolnay. This library provides a safe mechanism for calling C++ code from Rust and Rust code from C++.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css" disabled="true">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css" disabled="true">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="css/cxx.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta property="og:image" content="https://cxx.rs/cxx.png"><meta property="og:site_name" content="CXX"><meta property="og:title" content="CXX — safe interop between Rust and C++"><meta name="twitter:image:src" content="https://cxx.rs/cxx.png"><meta name="twitter:site" content="@davidtolnay"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="CXX — safe interop between Rust and C++"></head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>const html = document.documentElement;
html.classList.add('js');</script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list" style="display:none">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="https://github.com/dtolnay/cxx" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="extern-rust"><a class="header" href="#extern-rust">extern "Rust"</a></h1>
<pre><code class="noplayground hidelines hide-boring hljs"><span class="hljs-meta">#[cxx::bridge]</span>
<span class="hljs-keyword">mod</span> ffi {
    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;Rust&quot;</span> {

    }
}</code></pre>
<p>The <code class="hljs">extern "Rust"</code> section of a CXX bridge declares Rust types and signatures
to be made available to C++.</p>
<p>The CXX code generator uses your extern "Rust" section(s) to produce a C++
header file containing the corresponding C++ declarations. The generated header
has the same path as the Rust source file containing the bridge, except with a
<code class="hljs">.rs.h</code> file extension.</p>
<p>A bridge module may contain zero or more extern "Rust" blocks.</p>
<h2 id="opaque-rust-types"><a class="header" href="#opaque-rust-types">Opaque Rust types</a></h2>
<p>Types defined in Rust that are made available to C++, but only behind an
indirection.</p>
<pre><code class="noplayground hidelines hide-boring hljs"><span class="boring"><span class="hljs-meta">#[cxx::bridge]</span>
</span><span class="boring"><span class="hljs-keyword">mod</span> ffi {
</span>    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;Rust&quot;</span> {
        <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyType</span></span>;
        <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyOtherType</span></span>;
        <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">OneMoreType</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;;
    }
<span class="boring">}</span></code></pre>
<p>For example in the <em><strong><a href="tutorial.html">Tutorial</a></strong></em> we saw <code class="hljs">MultiBuf</code> used in this
way. Rust code created the <code class="hljs">MultiBuf</code>, passed a <code class="hljs">&amp;mut MultiBuf</code> to C++, and C++
later passed a <code class="hljs">&amp;mut MultiBuf</code> back across the bridge to Rust.</p>
<p>Another example is the one on the <em><strong><a href="binding/box.html">Box&lt;T&gt;</a></strong></em> page, which
exposes the Rust standard library's <code class="hljs">std::fs::File</code> to C++ as an opaque type in
a similar way but with Box as the indirection rather than &amp;mut.</p>
<p>The types named as opaque types (<code class="hljs">MyType</code> etc) refer to types in the <code class="hljs">super</code>
module, the parent module of the CXX bridge. You can think of an opaque type <code class="hljs">T</code>
as being like a re-export <code class="hljs">use super::T</code> made available to C++ via the generated
header.</p>
<p>Opaque types are currently required to be <a href="https://doc.rust-lang.org/std/marker/trait.Sized.html"><code class="hljs">Sized</code></a> and <a href="https://doc.rust-lang.org/std/marker/trait.Unpin.html"><code class="hljs">Unpin</code></a>. In
particular, a trait object <code class="hljs">dyn MyTrait</code> or slice <code class="hljs">[T]</code> may not be used for an
opaque Rust type. These restrictions may be lifted in the future.</p>
<p>For now, types used as extern Rust types are required to be defined by the same
crate that contains the bridge using them. This restriction may be lifted in the
future.</p>
<p>The bridge's parent module will contain the appropriate imports or definitions
for these types.</p>
<pre><code class="noplayground hidelines hide-boring hljs"><span class="hljs-keyword">use</span> path::to::MyType;

<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyOtherType</span></span> {
    ...
}
<span class="boring">
</span><span class="boring"><span class="hljs-meta">#[cxx::bridge]</span>
</span><span class="boring"><span class="hljs-keyword">mod</span> ffi {
</span><span class="boring">    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;Rust&quot;</span> {
</span><span class="boring">        <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyType</span></span>;
</span><span class="boring">        <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyOtherType</span></span>;
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Rust functions made callable to C++.</p>
<p>Just like for opaque types, these functions refer implicitly to something in
scope in the <code class="hljs">super</code> module, whether defined there or imported by some <code class="hljs">use</code>
statement.</p>
<pre><code class="noplayground hidelines hide-boring hljs"><span class="hljs-meta">#[cxx::bridge]</span>
<span class="hljs-keyword">mod</span> ffi {
    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;Rust&quot;</span> {
        <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyType</span></span>;
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">f</span></span>() -&gt; <span class="hljs-built_in">Box</span>&lt;MyType&gt;;
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyType</span></span>(<span class="hljs-built_in">i32</span>);

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">f</span></span>() -&gt; <span class="hljs-built_in">Box</span>&lt;MyType&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Box</span>::new(MyType(<span class="hljs-number">1</span>));
}</code></pre>
<p>Extern Rust function signature may consist of types defined in the bridge,
primitives, and <a href="bindings.html">any of these additional bindings</a>.</p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>Any signature with a <code class="hljs">self</code> parameter is interpreted as a Rust method and
exposed to C++ as a non-static member function.</p>
<pre><code class="noplayground hidelines hide-boring hljs"><span class="boring"><span class="hljs-meta">#[cxx::bridge]</span>
</span><span class="boring"><span class="hljs-keyword">mod</span> ffi {
</span>    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;Rust&quot;</span> {
        <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyType</span></span>;
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">f</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">usize</span>;
    }
<span class="boring">}</span></code></pre>
<p>The <code class="hljs">self</code> parameter may be a shared reference <code class="hljs">&amp;self</code>, an exclusive reference
<code class="hljs">&amp;mut self</code>, or a pinned reference <code class="hljs">self: Pin&lt;&amp;mut Self&gt;</code>. A by-value <code class="hljs">self</code> is
not currently supported.</p>
<p>If the surrounding <code class="hljs">extern "Rust"</code> block contains exactly one extern type, that
type is implicitly the receiver for a <code class="hljs">&amp;self</code> or <code class="hljs">&amp;mut self</code> method. If the
surrounding block contains <em>more than one</em> extern type, a receiver type must be
provided explicitly for the self parameter, or you can consider splitting into
multiple extern blocks.</p>
<pre><code class="noplayground hidelines hide-boring hljs"><span class="boring"><span class="hljs-meta">#[cxx::bridge]</span>
</span><span class="boring"><span class="hljs-keyword">mod</span> ffi {
</span>    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;Rust&quot;</span> {
        <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">First</span></span>;
        <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Second</span></span>;
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>(<span class="hljs-keyword">self</span>: &amp;First);
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(<span class="hljs-keyword">self</span>: &amp;<span class="hljs-keyword">mut</span> Second);
    }
<span class="boring">}</span></code></pre>
<h2 id="associated-functions"><a class="header" href="#associated-functions">Associated functions</a></h2>
<p>A function with a <code class="hljs">Self</code> attribute is interpreted as a Rust associated function
and exposed to C++ as a static member function. These must not have a <code class="hljs">self</code>
argument.</p>
<p>In the following example, the <code class="hljs">builder</code> associated function is callable as
<code class="hljs">MyType::builder()</code> from both Rust and C++.</p>
<pre><code class="noplayground hidelines hide-boring hljs"><span class="hljs-meta">#[cxx::bridge]</span>
<span class="hljs-keyword">mod</span> ffi {
    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;Rust&quot;</span> {
        <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyType</span></span>;
        <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyTypeBuilder</span></span>;

        <span class="hljs-meta">#[Self = <span class="hljs-meta-string">&quot;MyType&quot;</span>]</span>
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">builder</span></span>() -&gt; <span class="hljs-built_in">Box</span>&lt;MyTypeBuilder&gt;;
    }
}

<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyType</span></span>;
<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyTypeBuilder</span></span>;

<span class="hljs-keyword">impl</span> MyType {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">builder</span></span>() -&gt; <span class="hljs-built_in">Box</span>&lt;MyTypeBuilder&gt; {
        ...
    }
}</code></pre>
<h2 id="functions-with-explicit-lifetimes"><a class="header" href="#functions-with-explicit-lifetimes">Functions with explicit lifetimes</a></h2>
<p>An extern Rust function signature is allowed to contain explicit lifetimes but
in this case the function must be declared unsafe-to-call. This is pretty
meaningless given we're talking about calls from C++, but at least it draws some
extra attention from the caller that they may be responsible for upholding some
atypical lifetime relationship.</p>
<pre><code class="noplayground hidelines hide-boring hljs"><span class="hljs-meta">#[cxx::bridge]</span>
<span class="hljs-keyword">mod</span> ffi {
    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;Rust&quot;</span> {
        <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyType</span></span>;
        <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">f</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>, s: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>;
    }
}</code></pre>
<p>Bounds on a lifetime (like <code class="hljs">&lt;'a, 'b: 'a&gt;</code>) are not currently supported. Nor are
type parameters or where-clauses.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="reference.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="extern-c++.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="reference.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="extern-c++.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>






        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
